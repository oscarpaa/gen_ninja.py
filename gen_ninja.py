import re
import subprocess
import sys


def ninja_for_to_bash(block):
    lines = block.splitlines()

    ninja_line = None
    other_lines = []

    for line in lines:
        stripped = line.strip()
        if (
            ninja_line is None
            and stripped.startswith('for ')
            and '%' in stripped
            and ';' in stripped
        ):
            ninja_line = stripped
        else:
            other_lines.append(line)

    if not ninja_line:
        return block

    m = re.findall(r'^for\s+(\w+)\s+in\s+([^\s;]+);(.+)$', ninja_line)
    if not m:
        return block

    var, pattern, body = m[0]

    pre, post = pattern.split('%', 1)
    glob = pattern.replace('%', '*')

    body = body.replace('%', '${cap}')
    body = body.replace(f'${var}', f'${{{var}}}')

    bash = (
        f'shopt -s nullglob; '
        f'for {var} in {glob}; do '
        f'cap="${{{var}#{pre}}}"; '
        f'cap="${{cap%{post}}}"; '
        f'echo "{body.strip()}"; '
        f'done'
    )

    rest = '\n'.join(other_lines).strip()
    if rest:
        bash += '\n' + rest

    return bash


def expand_bash_commands(template_path):
    with open(template_path) as f:
        lines = f.readlines()

    output = []
    i = 0

    while i < len(lines):
        line = lines[i]

        # Skip commented lines
        if line.lstrip().startswith('#'):
            output.append(line)
            i += 1
            continue

        if '$(' not in line:
            output.append(line)
            i += 1
            continue

        before, rest = line.split('$(', 1)
        output.append(before)

        block = []
        depth = 1

        block.append(rest)
        depth -= rest.count(')')

        i += 1

        # Read until balanced ')'
        while depth > 0 and i < len(lines):
            part = lines[i]
            block.append(part)
            depth += part.count('$(')
            depth -= part.count(')')
            i += 1

        bash_cmd = ''.join(block)
        bash_cmd = bash_cmd.rsplit(')', 1)[0].strip()

        bash_cmd = ninja_for_to_bash(bash_cmd)

        try:
            out = subprocess.check_output(
                ['bash', '-c', bash_cmd],
                text=True
            ).strip()
        except subprocess.CalledProcessError:
            print(f"[!] Error executing bash block:\n{bash_cmd}")
            sys.exit(1)

        if out:
            output.append(out + '\n')

    return ''.join(output)


if __name__ == "__main__":
    script_name = sys.argv[0]

    if len(sys.argv) < 2:
        print(f"[!] Usage: python3 {script_name} <template> [output]")
        sys.exit(1)

    input_template = sys.argv[1]
    output_ninja = sys.argv[2] if len(sys.argv) == 3 else "build.ninja"

    final_content = expand_bash_commands(input_template)

    header = [
        f"# AUTOMATICALLY GENERATED FROM {input_template}",
        f"# Generated by {script_name}\n",
        "rule regen_ninja",
        f"  command = python3 {script_name} {input_template} {output_ninja}",
        "  generator = 1\n",
        f"build {output_ninja}: regen_ninja {input_template} {script_name}\n",
        "#" + "-" * 40 + "\n"
    ]

    with open(output_ninja, "w") as f:
        f.write("\n".join(header) + "\n" + final_content)

    print(f"[*] {output_ninja} successfully generated")
